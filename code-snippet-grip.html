<!DOCTYPE HTML>
<html>
    <head>
        <title>Code Implementation - MARS Robot</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="assets/css/main.css" />
        
        <style>
            /* This ensures the code block is centered but the text inside is left-aligned */
            .code-wrapper {
                max-width: 900px;
                margin: 0 auto 2rem auto;
                text-align: left;
                background-color: #272822; /* Monokai-ish dark background */
                border-radius: 6px;
                box-shadow: 0 4px 15px rgba(0,0,0,0.1);
                overflow-x: auto; /* Adds scrollbar if code is too wide */
            }

            pre {
                margin: 0;
                padding: 1.5rem;
            }

            code {
                font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
                font-size: 0.9em;
                color: #f8f8f2; /* Light text code color */
                line-height: 1.6;
            }

            /* Optional: Syntax highlighting simulation colors */
            .keyword { color: #f92672; font-weight: bold; }
            .func { color: #66d9ef; }
            .string { color: #e6db74; }
            .comment { color: #75715e; font-style: italic; }
        </style>
    </head>
    <body>

        <div id="wrapper" class="divided">

                <section class="banner style1 orient-center content-align-center image-position-center onload-image-fade-in onload-content-fade-right">
                        <div class="content">
                            <h1>Code Implementation</h1>
                            <p class="major">A deep dive into the ROS2 nodes and logic controlling the MARS robot.</p>
                            <ul class="actions vertical">
                                <li><a href="index.html#grip" class="button big wide smooth-scroll-middle">Return to Main Page</a></li>
                            </ul>
                        </div>
                        <div class="image">
                            <img src="images/spotlight01.jpg" alt="" />
                        </div>
                    </section>

                <section class="wrapper style1 align-center" id="detection">
                        <div class="inner">
                            <h2>1. Detection Module</h2>
                            <p>This snippet demonstrates how we initialize the computer vision node to identify the ball using color filtering and contour detection.</p>
                            <h4>Grip and Manipulation</h4>

<p>This section describes how the robot physically interacts with the object once it has been detected and approached. The manipulation pipeline includes arm path planning, inverse kinematics–based joint control, and gripper actuation using servo motors. Unlike the driving and perception system, which operates primarily in the planar workspace, manipulation requires careful coordination in 3D space to ensure accurate positioning and reliable grasping.</p>

<p>The gripping system was designed to be modular and deterministic. Rather than relying on continuous visual servoing during grasp execution, the arm follows a structured sequence of predefined waypoints that guide it from a safe resting position to the final grasp pose. This approach simplifies control and increases robustness under real-world conditions.</p>

<h4>Arm Path Planning</h4>

<p>Arm motion is planned as a sequence of discrete poses rather than a single continuous trajectory. This design choice allows the robot to pause at key locations, reassess object position, and reduce the likelihood of collisions or misalignment.</p>

<p>The full trajectory is divided into four waypoints:</p>

<h4>Overhead Detection Position</h4>

<p>The arm first moves to an overhead pose that places the camera at its highest vantage point. This position is specifically chosen to maximize visibility of the object while minimizing occlusions from the arm itself. By separating detection from grasp execution, the system ensures that object localization is as accurate as possible before committing to motion.</p>

<h4>Midpoint Re-Evaluation Position</h4>

<p>After initial detection, the arm moves to an intermediate midpoint pose. At this location, the system re-evaluates the object’s position to account for any residual error from perception or robot motion. This step significantly improves grasp precision, especially when small localization errors could otherwise accumulate.</p>

<h4>Grasping Position</h4>

<p>The final grasping pose places the end effector directly above the object with a predefined offset along the z-axis. This offset ensures that the gripper approaches the object from above rather than colliding laterally. The pose is carefully chosen to align the gripper with the object’s center of mass, increasing grasp stability.</p>

<h4>Home Position</h4>

<p>Once the grasp is complete, the arm returns to a home position. This resets the system to a known, safe configuration and prepares it for subsequent tasks or shutdown.</p>

<h4>Inverse Kinematics and Arm Motion</h4>

<p>At each waypoint, the desired end-effector pose is converted into joint angles using the provided inverse kinematics (IK) solver. This abstraction allows the system to reason in task space rather than joint space, simplifying motion planning and improving readability.</p>

<p>The arm is controlled using twist commands published at 20 Hz, enabling smooth and continuous motion between poses. By maintaining a fixed update rate, the system avoids abrupt joint movements and reduces mechanical stress on the actuators. Each waypoint is reached sequentially, and motion only proceeds once the current pose has been achieved within tolerance.</p>

<h4>Gripper Actuation</h4>

<p>Once the arm reaches the final grasping pose, the gripper is actuated to secure the object. The gripper is controlled using PWM signals sent to servo motors, with fixed duty cycles corresponding to open and closed positions. This simple control scheme was sufficient for the task, as the object geometry and required grip force were known in advance.</p>

<p>A short delay is introduced after issuing a gripper command to allow time for mechanical motion to complete. This prevents premature transitions and ensures the object is fully secured before the arm moves away from the grasping pose.</p>

<h4>System Integration and Reliability</h4>

<p>The gripping pipeline is tightly integrated with perception and navigation but remains logically separate. Detection and approach are completed before manipulation begins, reducing system coupling and simplifying debugging. By relying on predefined arm waypoints and IK-based control, the manipulation system behaves predictably across repeated trials.</p>

<p>Overall, this approach prioritizes reliability and clarity over aggressive optimization. While more advanced techniques such as continuous visual servoing could further improve precision, the implemented solution proved robust and well-suited to the scope of the project.</p>
                            <div class="code-wrapper">
<pre><code><span class="comment"># Detection Node Snippet (Python / ROS2)</span>
import cv2
import numpy as np

<span class="keyword">def</span> <span class="func">detect_ball</span>(self, image_frame):
    <span class="comment"># Convert to HSV color space for better color segmentation</span>
    hsv = cv2.cvtColor(image_frame, cv2.COLOR_BGR2HSV)
    
    <span class="comment"># Define limits for the red ball</span>
    lower_red = np.array([0, 120, 70])
    upper_red = np.array([10, 255, 255])
    
    mask = cv2.inRange(hsv, lower_red, upper_red)
    contours, _ = cv2.findContours(mask, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    <span class="keyword">if</span> len(contours) > 0:
        c = max(contours, key=cv2.contourArea)
        ((x, y), radius) = cv2.minEnclosingCircle(c)
        <span class="keyword">return</span> (x, y, radius)
    <span class="keyword">return</span> None</code></pre>
                            </div>
                        </div>
                    </section>

                <section class="wrapper style1 align-center" id="planning">
                        <div class="inner">
                            <h2>2. Motion Planning</h2>
                            <p>Once the object is detected, we calculate the trajectory required to intercept the target. This path planning logic ensures smooth acceleration.</p>

                            <div class="code-wrapper">
<pre><code><span class="comment"># Planning Logic (C++ Implementation)</span>
<span class="keyword">void</span> <span class="func">calculate_trajectory</span>(Target target) {
    <span class="comment">// Calculate error between current robot pose and target</span>
    double error_x = target.x - current_pose.x;
    double error_theta = atan2(error_y, error_x) - current_pose.theta;

    <span class="comment">// Simple P-Controller for steering</span>
    double angular_vel = Kp_angular * error_theta;
    
    <span class="comment">// Dynamic speed adjustment based on turn angle</span>
    double linear_vel = max_speed * (1.0 - std::abs(error_theta) / M_PI);

    <span class="keyword">if</span> (dist_to_target < stop_threshold) {
        publish_cmd_vel(0.0, 0.0);
    } <span class="keyword">else</span> {
        publish_cmd_vel(linear_vel, angular_vel);
    }
}</code></pre>
                            </div>
                        </div>
                    </section>

                <section class="wrapper style1 align-center" id="actuation">
                        <div class="inner">
                            <h2>3. Actuation (Gripper)</h2>
                            <p>The final step is the mechanical actuation of the gripper to secure the ball. We use PWM signals to control the servo motors.</p>

                            <div class="code-wrapper">
<pre><code><span class="comment"># Servo Control Snippet</span>
<span class="keyword">def</span> <span class="func">activate_gripper</span>(state):
    <span class="keyword">if</span> state == <span class="string">"OPEN"</span>:
        pwm.set_duty_cycle(SERVO_PIN, 7.5) <span class="comment"># Neutral position</span>
        logger.info(<span class="string">"Gripper Opening..."</span>)
        
    <span class="keyword">elif</span> state == <span class="string">"CLOSE"</span>:
        pwm.set_duty_cycle(SERVO_PIN, 12.5) <span class="comment"># 180 degree position</span>
        logger.info(<span class="string">"Gripper Closing..."</span>)
        
    time.sleep(1.0) <span class="comment"># Allow time for mechanical movement</span></code></pre>
                            </div>
                        </div>
                    </section>

                <footer class="wrapper style1 align-center">
                        <div class="inner">
                            <!-- 
                            <ul class="icons">
                                <li><a href="#" class="icon style2 fa-github"><span class="label">GitHub</span></a></li>
                                <li><a href="#" class="icon style2 fa-linkedin"><span class="label">LinkedIn</span></a></li>
                                <li><a href="#" class="icon style2 fa-envelope"><span class="label">Email</span></a></li>
                            </ul>
                            -->
                            <p>&copy; Intro to Robotics Project. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
                        </div>
                    </footer> 

            </div>

        <script src="assets/js/jquery.min.js"></script>
            <script src="assets/js/jquery.scrollex.min.js"></script>
            <script src="assets/js/jquery.scrolly.min.js"></script>
            <script src="assets/js/skel.min.js"></script>
            <script src="assets/js/util.js"></script>
            <script src="assets/js/main.js"></script>

    </body>
</html>
