<!DOCTYPE html>
<html>
  <head>
    <title>Code Implementation - MARS Robot Actuation</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="assets/css/main.css" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />

    <style>
      /* --- Layout & Typography --- */
      .align-center p,
      .align-center ul,
      .align-center ol {
        text-align: left;
        max-width: 800px;
        margin-left: auto;
        margin-right: auto;
        font-size: 1.1em;
        line-height: 1.8;
        margin-bottom: 2rem;
      }

      .align-center h2,
      .align-center h3,
      .align-center h4 {
        text-align: center;
        margin-bottom: 1.5rem;
      }

      /* --- Code Block Styling --- */
      .code-wrapper {
        width: 90%;
        max-width: 1000px;
        margin: 2rem auto;
        background-color: #272822;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        text-align: left;
        position: relative;
        overflow: hidden;
      }

      .code-wrapper pre[class*="language-"] {
        margin: 0 !important;
        padding: 1.5rem !important;
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        width: 100%;
        overflow-x: auto;
      }

      code[class*="language-"],
      pre[class*="language-"] {
        font-family: "Consolas", "Monaco", "Courier New", monospace !important;
        font-size: 0.95em !important;
        line-height: 1.6 !important;
        text-shadow: none !important;
      }
    </style>
  </head>

  <body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <div id="wrapper" class="divided">
      <section
        class="banner style1 orient-center content-align-center image-position-center onload-image-fade-in onload-content-fade-right"
      >
        <div class="content">
          <h1>Full System Actuation</h1>
          <p class="major">
            This page details the complete control stack of the MARS robot. From
            the <strong>Closed-Loop Driving Controller</strong> that tracks
            trajectories, to the
            <strong>Manipulation State Machine</strong> that orchestrates
            complex arm movements, and finally the
            <strong>PWM Gripper Control</strong> for physical interaction.
          </p>
          <ul class="actions vertical">
            <li>
              <a
                href="index.html#grip"
                class="button big wide smooth-scroll-middle"
                >Return to Main Page</a
              >
            </li>
          </ul>
        </div>
        <div class="image">
          <img src="images/actuation.jpg" alt="Robot driving and grasping" />
        </div>
      </section>

      <section class="wrapper style1 align-center" id="driving">
        <div class="inner">
          <h2>1. Driving Control (Base Actuation)</h2>
          <p>
            The robot's base is a differential drive system. To achieve smooth,
            human-like motion, we do not simply send "go" commands. Instead, we
            implemented a
            <strong>Closed-Loop Controller running at 20Hz</strong>.
          </p>
          <p>
            This controller continuously compares the robot's current heading
            (from Odometry/TF) against the desired BÃ©zier waypoint. It
            calculates error and outputs precise velocity commands (<code
              >Twist</code
            >
            messages) to the <code>/cmd_vel</code> topic. We also implemented a
            <strong>Low-Pass Filter</strong> on the angular velocity to prevent
            wheel slip and mechanical oscillation.
          </p>
        </div>

        <div class="code-wrapper">
          <pre><code class="language-python"># From move_to_object.py: Control Loop

def control_loop(self):
    """Executes at 20Hz to drive the robot"""
    # 1. Get current pose from TF
    pose = self.get_current_pose()
    
    # 2. Calculate Heading Error to target waypoint
    angle_to_target = math.atan2(dy, dx)
    angle_error = self.normalize_angle(angle_to_target - pose.yaw)
    
    # 3. Apply Low-Pass Filter (Smooths the turn)
    raw_angular_vel = self.kp_angular * angle_error
    self.filtered_angular_vel = (self.alpha * raw_angular_vel) + ((1 - self.alpha) * self.filtered_angular_vel)
    
    # 4. Publish Velocity
    twist = Twist()
    twist.linear.x = linear_vel
    twist.angular.z = self.filtered_angular_vel
    self.cmd_vel_pub.publish(twist)</code></pre>
        </div>
      </section>

      <section class="wrapper style1 align-center" id="arm-logic">
        <div class="inner">
          <h2>2. Arm Logic: The State Machine</h2>

          <p>
            Unlike the base, the arm requires discrete logic states to operate
            safely. We cannot simply "move to the ball" because the arm might
            collide with the object or block the camera view. We implemented a
            <strong>Finite State Machine (FSM)</strong> to strictly enforce the
            sequence of operations.
          </p>

          <div class="box alt">
            <span class="image fit"
              ><img src="images/fsm.jpg" alt="Arm State Machine Logic"
            /></span>
          </div>

          <p>
            The system transitions through specific states: first moving to an
            <strong>Overhead</strong> position to verify the object location,
            then descending vertically to <strong>Grasp</strong>, and finally
            retracting to a <strong>Home</strong> pose.
          </p>
        </div>

        <div class="code-wrapper">
          <pre><code class="language-python"># From arm_movement.py: State Machine Definitions

class GraspState(Enum):
    IDLE = 0
    MOVE_TO_OVERHEAD = 2       # Lift arm to clear camera view
    POSITION_ABOVE_OBJECT = 6  # Align XY coordinates
    LOWER_TO_OBJECT = 8        # Vertical Z descent
    CLOSE_GRIPPER = 10         # Actuate end-effector
    RETURN_TO_REST = 11        # Safe transport pose

def update_arm_state(self):
    """ Transitions states based on motion completion flags """
    if self.state == GraspState.MOVE_TO_OVERHEAD and self.motion_complete:
        self.state = GraspState.POSITION_ABOVE_OBJECT
        self.motion_complete = False</code></pre>
        </div>
      </section>

      <section class="wrapper style1 align-center" id="ik">
        <div class="inner">
          <h3>3. Actuating the Joints (Inverse Kinematics)</h3>
          <p>
            To move the arm to a specific 3D coordinate (x, y, z), we must
            calculate the required angles for all 5 joints. We use an
            <strong>Inverse Kinematics (IK) Solver</strong> that takes the
            target coordinate in the base frame and outputs the necessary joint
            configurations.
          </p>

          <p>
            These joint targets are published to the
            <code>/joint_states</code> topic, which the lower-level hardware
            drivers use to move the servos.
          </p>
        </div>

        <div class="code-wrapper">
          <pre><code class="language-python"># From arm_movement.py: Kinematics

def move_arm_to_coords(self, x, y, z):
    """Calculates joint angles for a target 3D point"""
    
    # 1. Transform Camera Detection -> Base Frame
    target_base = self.transform_camera_to_base(x, y, z)
    
    # 2. Solve IK
    joint_angles = self.ik_solver.calculate_ik(target_base.x, target_base.y, target_base.z)
    
    # 3. Publish to hardware
    msg = JointState()
    msg.position = joint_angles
    self.joint_pub.publish(msg)</code></pre>
        </div>
      </section>

      <section class="wrapper style1 align-center" id="gripper">
        <div class="inner">
          <h2>4. End-Effector (Gripper) Actuation</h2>
          <p>
            The final stage of actuation is physical interaction. The gripper is
            driven by a servo motor controlled via
            <strong>Pulse Width Modulation (PWM)</strong> signals. We determined
            specific duty cycles corresponding to the "Open" (7.5) and "Closed"
            (12.5) positions to ensure a firm grasp on the paper ball.
          </p>

          <div class="box alt">
            <span class="image fit" style="max-width: 600px; margin: 0 auto">
              <img src="images/gripper.GIF" alt="Gripper Closing Action" />
            </span>
          </div>
        </div>

        <div class="code-wrapper">
          <pre><code class="language-python"># From arm_movement.py: Servo Control

def activate_gripper(state):
    """Direct PWM control of the gripper servo"""
    if state == "OPEN":
        # Neutral position (0 degrees)
        pwm.set_duty_cycle(SERVO_PIN, 7.5) 
        
    elif state == "CLOSE":
        # 180 degree position (Fully clamped)
        pwm.set_duty_cycle(SERVO_PIN, 12.5) 
        
    # Block thread to ensure mechanical completion
    time.sleep(1.0)</code></pre>
        </div>
      </section>

      <footer class="wrapper style1 align-center">
        <div class="inner">
          <p>
            &copy; Intro to Robotics Project. Design:
            <a href="https://html5up.net">HTML5 UP</a>.
          </p>
        </div>
      </footer>
    </div>

    <script src="assets/js/jquery.min.js"></script>
    <script src="assets/js/jquery.scrollex.min.js"></script>
    <script src="assets/js/jquery.scrolly.min.js"></script>
    <script src="assets/js/skel.min.js"></script>
    <script src="assets/js/util.js"></script>
    <script src="assets/js/main.js"></script>
  </body>
</html>
